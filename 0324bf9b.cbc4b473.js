(window.webpackJsonp=window.webpackJsonp||[]).push([[5],{58:function(e,t,o){"use strict";o.r(t),o.d(t,"frontMatter",(function(){return i})),o.d(t,"metadata",(function(){return s})),o.d(t,"rightToc",(function(){return l})),o.d(t,"default",(function(){return h}));var r=o(2),n=o(6),a=(o(0),o(97)),i={id:"20209-6-obspectrophore",title:"Fall20-W6 Spectrophores (TM)",tags:["OpenBabel","Virtual Screening","ML"]},s={unversionedId:"research-pages/20209-6-obspectrophore",id:"research-pages/20209-6-obspectrophore",isDocsHomePage:!1,title:"Fall20-W6 Spectrophores (TM)",description:"Objective",source:"@site/docs/research-pages/20209-week6-obspectrophore.md",slug:"/research-pages/20209-6-obspectrophore",permalink:"/docs/research-pages/20209-6-obspectrophore",editUrl:"https://github.com/eternal-flame-AD/vds-yumechi-top/edit/master/docs/research-pages/20209-week6-obspectrophore.md",version:"current",sidebar:"someSidebar",previous:{title:"Fall20-W6 Target Virtual Screening - Chembridge Economy",permalink:"/docs/research-pages/20209-6-vs-chbre"},next:{title:"Fall20-W7 Target Virtual Screening - Chembridge Economy (VINA)",permalink:"/docs/research-pages/20209-7-vs-chbre-vina"}},l=[{value:"Objective",id:"objective",children:[]},{value:"Methods (Work In Progress)",id:"methods-work-in-progress",children:[{value:"Preparation for library (once per library)",id:"preparation-for-library-once-per-library",children:[]},{value:"Clustering",id:"clustering",children:[]},{value:"Evaluation",id:"evaluation",children:[]}]},{value:"Discussion",id:"discussion",children:[]}],c={rightToc:l};function h(e){var t=e.components,o=Object(n.a)(e,["components"]);return Object(a.b)("wrapper",Object(r.a)({},c,o,{components:t,mdxType:"MDXLayout"}),Object(a.b)("h2",{id:"objective"},"Objective"),Object(a.b)("p",null,"When docking extra-large libraries, there may be a lot of occurences of similar molecules within the library."),Object(a.b)("p",null,"Thus, it may be beneficial to first cluster the library and do a preliminary scan by docking samples from each cluster to predict\nthe overall competence of each cluster to the receptor without having to dock every single ligand in the library. Then, clusters\nwith poor performances can be excluded from the dock while good libraries will be docked in full in order to find the best-performing molecule\nin the cluster."),Object(a.b)("p",null,"Generally speaking, when the library is very large compared to the available computational resource,\nwe are not expecting to put every molecule through the screening stage. Thus, there will be a problem of\nwhich molecule to dock and which to skip. For this problem there are several solutions that I want to discuss:"),Object(a.b)("ol",{start:0},Object(a.b)("li",{parentName:"ol"},"The most obvious is a naive random selection - say we only dock 50% of the library by random choice. In theory we would also\nonly get 50% of the hits as result.")),Object(a.b)("p",null,"To get more than 50% of the hits with only 50% of the CPU time, there are several heuristic methods available:"),Object(a.b)("ol",null,Object(a.b)("li",{parentName:"ol"},Object(a.b)("p",{parentName:"li"},"Only dock molecules with matching pharmacophore features.\nThis is a very good method to use and I have seen many papers using this method. Generally the idea is to use researcher's input\nto filter out clearly unsuitable ligands.\nThe general idea of this approach is that: in the end the good matches will have most of the desired pharmacophore points\nthat the receptor wants, thus we can first exclude molecules that simply can't satisfy these constraints geometrically.\nThis approach is good in that it is very fast and very accurate as long as the prediction is good. However, when\na clear pharmacophore point in the receptor can not be determined confidently (complex receptor, multiple binding modes, etc),\nthis method can be hard to implement.")),Object(a.b)("li",{parentName:"ol"},Object(a.b)("p",{parentName:"li"},'A "quick" dock followed by a "slow" dock for top hits.\nGenerally speaking, I don\'t see this method as significantly better than naive random selection. The main problem is,\ndocking program score poses strictly on molecular mechanics (or similar ways). Thus, the scoring function is usually very strict (in a sense of 1 to 2 angstroms)\nin that a small deviation from the "ideal" pose may lead to a significant score loss (may not be better than random at all).\n(Well to verify this, we can write a program that does some small transformation on the ligand and send the new pose to GOLD\nscore function and see how much the score has changed.) Another problem is a "quick" dock does not come for free either. A simple math: let\'s say the "quick" dock takes 20% of the CPU time than the "slow" dock.\n(pretty generous, normally you wouldn\'t expect this much a speed boost)\nThat means, if our CPU time budget is enough for docking 50% percent of ligands in "slow" mode, after the "quick" dock we can only do 30% of the ligands. In other words,\nin order to "earn back" the CPU time we lost for the preliminary dock, it at least need to provide almost twice the selectivity compared to random to merely\ncome in equal with the naive solution.'))),Object(a.b)("p",null,"To give some numbers to back my hypothesis:"),Object(a.b)("p",null,"GOLD is not open-source so I can't say much about GOLD, but for VINA, the energy well for VINA is (from VINA paper):\n(1) 1.0 A for hydrophobic terms\n(2) 0.7 A for H bonds\nIf the monte-carlo search can't hit inside this well,\nit won't be accepted as a possible pose, thus, we will miss the pose and, unless their is another good binding pose enough to let\nthis molecule stand out, this molecule will be excluded from the search.So I dug into the source of VINA and looked at their implementation of \"exhaustiveness\", basically it simply indicates how many repeats should\nthe monte carlo search be done. Every time the search tries to shift the molecule by 2 A (from VINA source code). So a rough estimate for the\nsampling accuracy for the default exhaustiveness 8 would be 0.5 A. Halfing this value would be have the CPU time but half the probability of discovering a pose (since the step would be larger\nthan the energy well). Which defeats the purpose of a heuristic screening."),Object(a.b)("p",null,"My proposal is to make the scale of the ligands smaller by clustering them into bins and only sample results from the bins.\nThe general idea is, molecules with similar 3D characteristics should behave similarly in screening. Thus, by taking samples from\na cluster of closely-related molecules, we can predict the approximate performance of this group of molecules has we docked all of them.\nIn this way, we can exclude groups of molecules that are unlikely to success (multiple samples from the bin behaved poorly)."),Object(a.b)("h2",{id:"methods-work-in-progress"},"Methods (Work In Progress)"),Object(a.b)("h3",{id:"preparation-for-library-once-per-library"},"Preparation for library (once per library)"),Object(a.b)("ol",null,Object(a.b)("li",{parentName:"ol"},Object(a.b)("p",{parentName:"li"},"Generate spectrophore(TM) information of each molecule with ",Object(a.b)("a",Object(r.a)({parentName:"p"},{href:"https://openbabel.org/docs/dev/Fingerprints/spectrophore.html"}),"OpenBabel - obspectrophore application"),"."),Object(a.b)("p",{parentName:"li"},"This should be a relatively quick process (<30 mins on a single KNL node for my 13 million ZINC library)."),Object(a.b)("p",{parentName:"li"},"It will reduce the whole 3-D structure into a 48-dimension vector by considering molecular features such as shape,\nlipophilicity, electrophilicity, etc. (see obspectrophore page for details)\nThese properties that are just happens to be important variables to consider in virtual screening, namely:"),Object(a.b)("ul",{parentName:"li"},Object(a.b)("li",{parentName:"ul"},"Shape of molecule"),Object(a.b)("li",{parentName:"ul"},"Magnitude and positioning of features"),Object(a.b)("li",{parentName:"ul"},"Surface area")),Object(a.b)("p",{parentName:"li"},"Thus, I predict that molecules that produce similar results in obspectrophore should get similar results in virtual screening."))),Object(a.b)("h3",{id:"clustering"},"Clustering"),Object(a.b)("ol",{start:2},Object(a.b)("li",{parentName:"ol"},Object(a.b)("p",{parentName:"li"},"Train a K-Means model to sort the ligands into clusters besed on obtained spectrophore vectors."),Object(a.b)("p",{parentName:"li"},"For this part I custom-coded a K-means implementation to run fast enough on KNL by utilizing AVX512 instructions.\nAlgorithm Reference: ",Object(a.b)("a",Object(r.a)({parentName:"p"},{href:"http://cs229.stanford.edu/notes/cs229-notes7a.pdf"}),"http://cs229.stanford.edu/notes/cs229-notes7a.pdf")),Object(a.b)("p",{parentName:"li"},"This is a relatively easy-to-implement and robust clustering algorithm in ML."),Object(a.b)("p",{parentName:"li"},"For my 13 million library, I set the algorithm to make 50k bins, the algorithm converged after 50 cycles (~80hrs of total\ncomputation on a single KNL node)."),Object(a.b)("p",{parentName:"li"},"The model reusable in theory as long as the number of bins stays the same, have not tested this in the context of molecular clustering.")),Object(a.b)("li",{parentName:"ol"},Object(a.b)("p",{parentName:"li"},"Evaluate the model on all ligands."),Object(a.b)("p",{parentName:"li"},"This is (almost) equiv to a cycle of training in terms of computational complexity. (Thus, <2h for my 13m library on a single KNL node)"))),Object(a.b)("h3",{id:"evaluation"},"Evaluation"),Object(a.b)("ol",{start:4},Object(a.b)("li",{parentName:"ol"},Object(a.b)("p",{parentName:"li"},"Scan through the library with desired virtual screening method by taking (k) samples randomly from each of the cluster.")),Object(a.b)("li",{parentName:"ol"},Object(a.b)("p",{parentName:"li"},'Exclude clusters that does not perform well. Multiple methods, simpliest one would be to just take the average of each cluster samples\nand exclude low scores. Alternatively, if the correlation is really strong, an statistical inference can be done to confidently say some cluster\nare unlikely to "success" just based on the sample.')),Object(a.b)("li",{parentName:"ol"},Object(a.b)("p",{parentName:"li"},"Dock every single molecule in the selected clusters to find best candidate(s)."))),Object(a.b)("h2",{id:"discussion"},"Discussion"),Object(a.b)("p",null,"I am planning on carrying out an evaluation on this. I have done some preliminary non-direct ways and sort of saw some good indicators. The next steps to verify these methods are:"),Object(a.b)("p",null,"(1) Statistically speaking, how much inference can we make on these clusters just based on limited sampling? (a.k.a. how much deviation in score within a cluster) comparatively easy to verify\n(2) A controlled docking. Basically: take some known inhibitors that the docking software can perform well on. Mix them into the bins. Run it through the algorithm. Calculate  (Selectivity %) / (CPU Time %) = f(p%) = (% of ligands in first p% bins) / (p%).\nI expect a ratio of at least 3 (3 times more controls selected than random) in a consider portion of 0% < p% < 50% to say using this method is worth the effort."))}h.isMDXComponent=!0},97:function(e,t,o){"use strict";o.d(t,"a",(function(){return p})),o.d(t,"b",(function(){return d}));var r=o(0),n=o.n(r);function a(e,t,o){return t in e?Object.defineProperty(e,t,{value:o,enumerable:!0,configurable:!0,writable:!0}):e[t]=o,e}function i(e,t){var o=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),o.push.apply(o,r)}return o}function s(e){for(var t=1;t<arguments.length;t++){var o=null!=arguments[t]?arguments[t]:{};t%2?i(Object(o),!0).forEach((function(t){a(e,t,o[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(o)):i(Object(o)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(o,t))}))}return e}function l(e,t){if(null==e)return{};var o,r,n=function(e,t){if(null==e)return{};var o,r,n={},a=Object.keys(e);for(r=0;r<a.length;r++)o=a[r],t.indexOf(o)>=0||(n[o]=e[o]);return n}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)o=a[r],t.indexOf(o)>=0||Object.prototype.propertyIsEnumerable.call(e,o)&&(n[o]=e[o])}return n}var c=n.a.createContext({}),h=function(e){var t=n.a.useContext(c),o=t;return e&&(o="function"==typeof e?e(t):s(s({},t),e)),o},p=function(e){var t=h(e.components);return n.a.createElement(c.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.a.createElement(n.a.Fragment,{},t)}},m=n.a.forwardRef((function(e,t){var o=e.components,r=e.mdxType,a=e.originalType,i=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),p=h(o),m=r,d=p["".concat(i,".").concat(m)]||p[m]||u[m]||a;return o?n.a.createElement(d,s(s({ref:t},c),{},{components:o})):n.a.createElement(d,s({ref:t},c))}));function d(e,t){var o=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var a=o.length,i=new Array(a);i[0]=m;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:r,i[1]=s;for(var c=2;c<a;c++)i[c]=o[c];return n.a.createElement.apply(null,i)}return n.a.createElement.apply(null,o)}m.displayName="MDXCreateElement"}}]);